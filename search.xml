<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js</title>
      <link href="2021/06/03/js/"/>
      <url>2021/06/03/js/</url>
      
        <content type="html"><![CDATA[<p>1.变量声明方式<br>    var<br>        变量可以重复声明<br>        变量声明能够被提升<br>        没有局部作用域<br>        function foo() {<br>            if(true) {<br>                var a = “hello”<br>            }<br>            console.log(a)<br>            function foo1() {<br>                console.log(a)<br>            }<br>            foo1()<br>        }<br>        foo()<br>        //函数内部的变量不允许在外部访问<br>        console.log(a)</p><pre><code>let    不可重复声明    变量声明不可被提升    有局部作用域const    不可重复声明    变量声明不可被提升    有局部作用域</code></pre><p>2.注释<br>    html <!-- --><br>    css  /*  <em>/<br>    js  /</em>  */<br>        //</p><p>3.数据类型<br>    基本数据类型<br>        number<br>            var a = 1<br>            var a = 1.1<br>            var a = 0X10<br>            var a = 010</p><pre><code>        NaN 不是一个数字        infinity        isFinite()            true 不是无穷            false 是无穷    string        "" / ''        json字符串        {            "name":"xiaoli",            "age":12        }    boolean        true        false      null        空引用数据类型    undefined        未定义引用数据类型    object        function        arr        正则        ……</code></pre><p>4.检测数据类型<br>    typeof<br>        -&gt;<br>        number string boolean undefined object function  </p><p>5.值传递，引用传递<br>    var a = 1;<br>    var b = a;<br>    b++<br>    console.log(a,b)</p><pre><code>var obj = {    name:"xiaoli",    age:3}var obj1 = objobj1.age++console.log(obj,obj1)</code></pre><p>6.操作符<br>    算数操作符<br>        + +=<br>        - -=<br>        * *=<br>        / /=<br>        %</p><pre><code>比较操作符    &gt;    &gt;=    &lt;    &lt;=    ==        先转换为同一数据类型再进行比较    ===        先比较数据类型，数据类型不一致直接返回false逻辑运算符    &amp;&amp;        同真为真，有假则假        1.如果第一个操作数位null/NaN/undefined/0/false/"",直接返回第一个操作数        2.如果第一个操作数位其他，返回第二个操作数        var gender = male;        var age = 6;        if (gender="male" &amp;&amp; age&gt;3) {        }        ||        有真即真，同假才假        1.如果第一个数是其他，则返回第一个数            2.如果第一个操作数是null,NaN,undefined,false,0,"" 则返回第二个操作数    !        !a,如果a不是boolean类型的，就先将a转换成boolean        取反三目操作符    表达式1 ? 表达式2 : 表达式3    var age = 12    var age &gt; 18 ? "成年人" : "未成年"=======08-19=======一元运算符    +          +3 //3        +true //1    ++        var a = 3;        console.log(a++)        console.log(++a)        var result = a++ + ++a                console.log(result)        console.log(a)    -          -3  //-3        -true  //-1        -(-true)  //1    --位运算   </code></pre><p>7.类型转换<br>    -&gt;number<br>        方式<br>            Number(a)<br>            +a<br>            -(-a)<br>            parseInt(a)<br>            parseFloat(a)</p><pre><code>    a的取值        string            ""  0            "hello"   NaN            "3"  3        boolean            true   1            false  0        null/undefined               0            NaN -&gt;string    方式        String(a)        a+""        a.toString()            var a = 12            console.log(a.toString())            注意：null/undefined不能调用    a的取值        number        boolean        null        undefined-&gt;boolean    方式        Boolean(a)        !!a    a的取值        number            0  false            1  true            NaN  false        string            "a"     true            ""      false        null/undefined            false</code></pre><p>8.流程控制语句<br>    1、分支语句<br>        if分支<br>            if() {</p><pre><code>        } else if() {        }        ...        else {        }    switch分支        解决if-else if -...-else繁琐，switch更加简洁一些        switch(v){            case c1:                ...                break;            case c2:                ...                break;            ...            default:                ...        }        v 表示变量        c1、c2、c3、... 常量当 v === c1的时候，执行c1代码块中的内容，break表示跳槽switch代码块2、循环语句    for        for(初始化; 结束判定条件; 迭代) {            循环体        }    while        初始化;        while(结束判定条件) {            循环体;            迭代        }    do-while        初始化;        do {            循环体;            迭代        }while(结束判定条件)    for-in        a的取值对象或者数组        for(var key in a) {            console.log(key)        }</code></pre><p>9.对象<br>    1、初始化<br>        1) 字面量<br>            var obj = {<br>                name:”xioali”,<br>                age:3<br>            }</p><pre><code>    2) 构造函数        var obj = new Object()          //var obj = {}        obj.name = "xiaoli";        obj.age = 3    2、访问    1) 点访问        obj.name    2) 中括号访问        obj["name"]        &lt;==&gt;        var name = "name"        obj[name]3、删除    delete obj.name======08-21========4、检测属性    in    hasOwnProperty()5、对象序列化和反序列化    对象序列化        将js对象转换成json字符串        var obj = {            name:"xiaoli",            age:3        }        var json = JSON.stringify(obj)        '{"name":"xiaoli","age":12}'            反序列化        将json字符串转回js对象        var json = '{"name":"xiaoli","age":12}'        var obj = JSON.parse(json)    案例：路由跳转，携带参数6、构造函数和原型    所有的构造函数都有一个原型    所有的原型都有一个constructor属性    静态属性/方法        Object.assgin(obj1,obj2)            var obj1 = {                name:"xiaoli",                age:3            }            var obj2 = {                gender:"male"            }        Object.keys(obj1)        Object.values(obj1)        Object.defineProperty()            https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty            数据描述符                configurable    默认false                enumerable      默认false                   value           默认undefined                writable        默认false                        访问器描述符                configurable                enumerable                get         读取    默认undefined                set         写入    默认undefined                        var obj = {};            Object.defineProperty(obj, 'property1', {                value: 42,                writable: false                // enumberable:true                configurable:true            });    非静态属性/方法：        声明在函数的原型对象中，所有的实例对象均可调用        constructor:构造者【构造函数】        toString()        valueOf()        hasOwnProperty()</code></pre><p>10.函数<br>    1、函数定义<br>        函数字面量/函数表达式<br>            var foo = function() {</p><pre><code>        }    函数声明        function foo() {        }    匿名函数        function() {}        使用：            var arr = [1,2,3,4]            arr.forEach(function(item,index){                console.log(item,index)            })2、函数调用    函数名()        function foo(name,age) {            console.log(name)            console.log(age)        }        foo("xiaoli",12,"male")        参数                new 构造函数()    函数名.call(this,参数列表)        function foo(name,age) {            console.log(name)            console.log(age)        }        foo.call(this,"name",12)        foo.call()        函数名.apply(this,[参数列表])        function foo(name,age) {            console.log(name)            console.log(age)            console.log(1)        }        foo.apply(this,["name",12])        foo.apply()    3、函数的内部属性    形参    arguments        类数组对象，接受实参的真正所在        function foo(name,age) {            console.log(name)            console.log(age)            console.log(arguments)        }        foo("xiaoli",12,"male")    this        this的指向跟函数调用有关        如果函数使用"()"来调用，那看一下括号前面是不是函数名，如果是，看函数名前面有没有对象            有，this指向该对象        没有，            Nodejs环境中    this --&gt; global对象            浏览器环境中 this --&gt; window对象        nodejs中的this和在浏览器中javascript中的this是不一样的        var money = "想要变成有钱人"            var obj1 = {                money:"我有一个亿",                foo:function(){                    console.log(this.money)                }            }            var obj2 = {                money:"同桌拥有一个亿"            }        // obj1.foo()        //通过. call手动更改指向了obj2        // obj1.foo.call(obj2)        // obj1.foo.apply(obj1)                            4、函数提升    1.函数字面量/表达式        var foo = function() {            console.log(12)        }        foo()        &lt;==&gt;        var foo;        foo = function() {            console.log(12)        }        foo()    2.函数声明提升        function foo() {            console.log(12)        }        foo()        举例：            var foo = function(){                console.log("仙女");            }            function foo(){                console.log("魔鬼");            }            foo();            &lt;==&gt;            function foo() {                console.log("魔鬼")            }            var foo;            foo = function(){                console.log("仙女");            }            foo()</code></pre><p>11.数组<br>    1、数组定义<br>        1.数组字面量<br>            var arr = []<br>            var arr = [1,”name”,{name:”xiaoli”},function foo() {}]</p><pre><code>    2.构造函数        var arr = new Array()        var arr = new Array(1)        var arr = new Array(1,2,3)    2、数组访问    中括号访问    var arr = [1,2,3]    console.log(arr[3])3、检测是否为数组    var arr = [1,2,3]    Array.isArray()        console.log(Array.isArray(arr))        instanceof         判断是否是某个构造函数的实例        console.log(arr instanceof Array)    Array.from()        Array.of()4、数组转换成字符串    var arr = [1,2,3]    a.toString()        console.log(arr.toString())    a.join()        console.log(arr.join(" "))    JSON.stringify()5、数组相关api    1.栈方法[改变原值]        pop()   从数组的最后取出一个元素             参数：none            返回值： 删除的元素            举例：                var arr = [1,2,3]                console.log(arr.pop())        push(p1,p2,....)  在数组的最后插入一个元素            参数：要插入的元素            返回值：新增元素后数组的长度            举例：                var arr = [1,2,3]                console.log(arr.push(4))    2.队列[改变原值]        shift()     将数组中第一个元素取出来            参数：none            返回值：删除的元素            举例：                var arr = [1,2,3]                console.log(arr.shift())        unshift(p1,p2,....)             参数：要插入的元素            返回值：新增元素后数组的长度            举例：                var arr = [1,2,3]                console.log(arr.shift(2))    3.排序方法[改变原值]        sort()            举例：                var arr = [3,2,1,12,21]                console.log(arr.sort()); // [1,12,2,21,3]            解决问题：                使用比较器函数sort(comparator)                    comparator为一个比较器函数，函数可以接受两个值a,b                        当a&gt;b返回1时，从小到大排序                        当a&gt;b返回-1时，从大到小排序                                var arr = [3,2,1,12,21]                var result = arr.sort(function(a,b) {                    if(a&gt;b){                        return 1                    }else {                        return -1                    }                })                console.log(result)               4.截取方法        concat()    [不改变原值]            将参数中的数组和原数组拼接            参数：一个或多个数组            返回值：合并后的数组            举例：                var arr = [1,23,3]                var arr1 = [1,1,1]                var arr2 = [2,2,2]                console.log(arr.concat(arr1,arr2))                slice(start,end)     [不改变原值]            从使用该方法的数组中截取一个子数组            参数：                start     起始索引位置                end     结束索引位置            返回值：截取到的子数组，包含起始位置的项，不包含结束位置的项            举例：                var arr1 = [1,2,3,4,5];                var arr2 = arr1.slice(2,4);                console.log(arr1); // [1,2,3,4,5]                console.log(arr2); // [3,4]            注意：                1. 如果只传递了一个参数，截取的就是从该位置之后所有的项，作为新数组                    var arr1 = [1,2,3,4,5];                    var arr2 = arr1.slice(2);                    console.log(arr1); // [1,2,3,4,5]                    console.log(arr2); // [3,4,5]                2. 如果传递的参数(起始位置)超出了调用改方法的数组的索引，返回的是一个空数组                    var arr1 = [1,2,3,4,5];                    var arr2 = arr1.slice(5,6);                    console.log(arr1); // [1,2,3,4,5]                    console.log(arr2); // []                splice(begin,delete[,p1,p2,...]) 【改变原值】            从数组中删除、插入、更新元素            参数：                begin                    起始位置（删除，插入）                delete                    删除的个数                p1,p2,...                    插入的值            返回值：                删除的元素组成的数组            一个参数                var arr1 = [1,2,3,4,5];                var arr2 = arr1.splice(1);                console.log(arr1); // [1]                console.log(arr2); // [2,3,4,5]                删除该位置之后的所有项，被删除项组成一个新数组            两个参数                var arr1 = [1,2,3,4,5];                var arr2 = arr1.splice(1,3);                console.log(arr1); // [1,5]                console.log(arr2); // [2,3,4]                截取数组，第一个参数为开始的位置                第二个参数为截取的个数            三个参数                替换                    第一个参数是开始位置                    第二个参数是删除的个数                    第三个参数是替换的元素                插入                    第一个参数是开始位置                    第二个参数是0                    第三个参数是插入的元素                var arr1 = [1,2,3,4,5];                var arr2 = arr1.splice(1,3,9);                console.log(arr1); // [1,9,5]                console.log(arr2); // [2,3,4]        5.迭代方法        forEach(function(item,index,arr){})            用法：遍历当前数组            参数：function(item,index,arr){}                每次遍历一次，这个匿名函数就会被调用一次，forEach将当前遍历的元素，索引，当前数组 当做实参传递给这个匿名函数            返回值：无                var arr = [1,2,3,4,5];                var result = arr.forEach(function(item,index,arr){                    console.log(item,'item');                    console.log(index,'index');                    console.log(arr,'arr');                })                console.log(result); // undefined                every(function(item,index,arr){})            用法：判断数组中所有的元素是否满足回调函数中给定的条件            参数：function(item,index,arr){}            返回值：                当每次回调函数返回值为true，every方法的结果为true,                当回调函数返回值有一次为false,every方法的结果就为false                var arr = [1,2,3,4,5];                var result = arr.every(function(item,index,arr){                    return item &gt; 3;                })                console.log(result); // false                var arr = [1,2,3,4,5];                var result = arr.every(function(item,index,arr){                    return item &gt; 0;                })                console.log(result); // true        some(function(item,index,arr){})            用法：判断数组中是否有满足条件的元素            参数：function(item,index,arr){}            返回值：                当回调函数有一次返回true,some方法的结果就为true                当每次回调函数返回false,some方法的结果才为falses                var arr = [1,2,3,4,5];                var result = arr.some(function(item,index,arr){                    return item &gt; 3;                })                console.log(result); // true                var arr = [1,2,3,4,5];                var result = arr.some(function(item,index,arr){                    return item &gt; 5;                })                console.log(result); // false        filter(function(item,index,arr){})            用法：筛选数组中满足条件的元素 (过滤)            参数：function(item,index,arr){}                当回调函数返回true,当前元素就会被添加到返回值数组中            返回值：                有满足给定条件的元素时，返回符合条件元素所组成的新数组，                没有满足给定条件的元素时，返回空数组                var arr = [1,2,3,4,5];                var result = arr.filter(function(item,index,arr){                    return item &gt; 3;                })                console.log(result); // [4,5]                var arr = [1,2,3,4,5];                var result = arr.filter(function(item,index,arr){                    return item &gt; 5;                })                console.log(result); // []        map(function(item,index,arr){})            用法：使用给定条件处理数组 (映射)            参数：function(item,index,arr){}                回调函数可以返回任意类型的值，这些值都会被添加到map方法的返回值数组中            返回值：                返回一个处理后的新数组                var arr = [1,2,3,4,5];                var result = arr.map(function(item,index,arr){                    return item &gt; 3;                })                console.log(result); // [false,false,false,true,true]            注意：                1. map() 不会对空数组进行检测                2. map() 不会改变原始数组    6.类数组转换为数组        1) [...arguments]               改方法只对拥有迭代器的类数组有效，所以自己创建的类数组需要添加迭代器        2) Array.from(arguments)        3) Array.prototype.slice.call(arguments)            举例：                function foo() {                    console.log(arguments)                    console.log([...arguments])                    console.log(Array.from(arguments))                    console.log(Array.prototype.slice.call(arguments))                }                foo(1,2)                // 添加迭代器                var obj = {                    0:"1",                    1:"2",                    length:2,                    [Symbol.iterator]: Array.prototype[Symbol.iterator]                }                console.log(obj)                console.log([...obj])</code></pre><p>12.正则表达式<br>    0、正则表达式修饰符<br>        i   ignoreCase    忽略大小写<br>        m   multiline   执行多行匹配<br>        g   global      全局匹配</p><pre><code>1、定义    字面量        var pattern = /正则表达式/正则表达式修饰符         举例：            var pattern = /he/img    构造函数        var pattern = new RegExp("正则表达式","正则表达式修饰符")        举例：            var pattern = new RegExp("\\d","img")2、正则表达式    1.字符类        .                匹配任意单个字符        \d &lt;==&gt; [0-9]    匹配任意数字        \D &lt;==&gt; [^0-9]   匹配任意非数字        ^[0-9]           表示以任意数字作为开始        \w &lt;==&gt; [a-zA-Z0-9_]  匹配任意字符        \W &lt;==&gt; [^a-zA-Z0-9_]  匹配任意非字符        \s          空白字符，tab，return...        \S          非空白字符    2.分组        ()代表分组，在正则表达式中用()包起来的内容代表了一个分组        /[a-z][0-9]/ig        匹配一个字符后拼接一个数字        a1        o2        d3        /([a-z])([0-9])/ig        匹配一个字符后拼接一个数字，分组匹配字符，分组匹配数字        a1     a     1        o2     o     2        d3     d     3        var str = 'qwe2r4t6'        var pattern = /([a-z])([0-9])/ig        console.log(pattern.exec(str))    3.数量词        exp{3}        将前面的表达式匹配3次        exp{3,5}     将前面的表达式匹配3~5次        exp{3,}     将前面的表达式匹配3+次        exp*         将前面的表达式匹配0次或多次        exp+         将前面的表达式匹配1次或多次        exp?         将前面的表达式匹配0次或1次        贪婪匹配            /\d{2,}/            尽可能多的匹配            var str = "abc123456789"            var pattern = /\d{2,}/ig            console.log(pattern.exec(str))        非贪婪匹配            /\d{2,}?/            尽可能少的匹配            var str = "abc123456789"            var pattern = /\d{2,}?/ig            console.log(pattern.exec(str))3、正则表达式原型中属性    flags       正则表达式模式的字符串表示          global      如果模式中包含g，则返回true    ignoreCase  如果模式中包含i，则返回true    multiline   如果模式中包含m，则返回true    source      正则表达式的字符串表示    lastIndex   如果正则表达式中有修饰符'g'，这时，在pattern中会维护lastIndex属性，记录下一次开始的位置，                当第二次执 行exec的时候，从lastIndex开始检索；如果正则表达式中没有修饰符'g'，不会维护lastIndex属性，每次执行exec，都是从开始位置检索    举例：        var str = 'hello world'        var pattern = /he/gim        console.log(pattern)        console.log(pattern.global)        console.log(pattern.multiline)        console.log(pattern.ignoreCase)4、正则表达式原型中方法    test()        检测字符串是否能够匹配模式        参数：字符串        返回值：true/false        举例：            var str = 'hello world'            var pattern = /he/gim            console.log(pattern.test(str))    exec()        检索出字符中的正则表达式，将满足要求的字符串放入数组中        参数：字符串        返回值：满足要求字符串组成的数组/null        举例：            var str = 'hello world'            var pattern = /l/gim            console.log(pattern.exec(str))            console.log(pattern.exec(str))            console.log(pattern.exec(str))            console.log(pattern.exec(str))                能否使用循环打印exec()?            var str = 'hello world'            var pattern = /l/gim            var temp = []            var result;            while(result = pattern.exec(str)) {                temp.push(result[0])            }            console.log(temp)            如果希望将满足条件的字符串放到一个数组中，如何实现？                var str = 'hello world'                var pattern = /l/gim                var temp = []                var result;                while(result = pattern.exec(str)) {                    console.log(result)                    temp.push(result[0])                }                console.log(temp)        方法match()  ---&gt;  字符串原型的方法            var str = 'hello world'            var pattern = /l/gim            console.log(str.match(pattern))5、案例    1.手机号的验证        第一位数字输入的必须是1，第二位数字输入的必须是3,4,5,7,8,9其中的一位，后面的只能输入0-9的数字，不能输入字母或其他的字符，输入的必须是一个十一位数的号码        var str = '17393141274';        var pattern = /^1[3,4,5,7,8,9][0-9]{9}$/img;        console.log(pattern.test(str));        通过$来限制手机的位数为11位        2. 将下方字符串中电话号码检索出        var str = "briup telephone is 0512-5511000, baidu telephone is 0100-5518888."        var pattern = /[0-9]{4}-[0-9]{7}/gim        var arr = []        var res;        while(res = pattern.exec(str)) {            arr.push(res[0])        }        console.log(arr)    3.邮箱的验证        规则：        @之前必须有内容且只能是字母（大小写）、数字、下划线(_)、减号（-）、点（.）        @和最后一个.之间必须有内容且只能是字母（大小写）、数字、点（.）、减号（-），且两个点不能紧挨着        最后一个.之后必须有内容且内容只能是字母（大小写）、数字且长度为大于等于2个字节，小于等于6个字节`            var str = 'zhangnn@briup.com'            var reg = /^[a-zA-Z0-9]+([-_.][a-zA-Z0-9]+)*@[a-zA-Z0-9]+([-_.][a-zA-Z0-9]+)*\.[a-z]{2,}$/            console.log(reg.test(str))</code></pre><p>13.包装器类型<br>    提供方法，让我们操作基本数据类型</p><pre><code>基本包装器    Number() String() Boolean() String.prototype.xxx    length        获取字符串中字数的数量        var str = 'helloworld';        var length = str.length;        console.log(length); // 10    charAt(index)        获取指定索引处的字符        var str = 'helloworld';        var char1 = str.charAt(2);        var char2 = str.charAt(20);        console.log(char1); // l        console.log(char2); // ''    charCodeAt(index)        获取指定索引处的字符编码        var str = 'helloworld';        var charCode = str.charCodeAt(2);        console.log(charCode); // 108    indexOf(val)        获取指定字符在字符串中首次出现时的索引，如果该字符不属于字符串，返回-1        var str = 'helloworld';        var char = str.indexOf('l');        console.log(char); // 2        拓展：数组去重   ---&gt;   数组中也有indexOf() 方法，可返回数组中某个指定的元素首次出现时的索引。            var arr = [1,2,3,1,2,5];                数组原索引：0 1 2 3 4 5                     检测结果：  0 1 2 0 1 5            function norepeat(arr){                for(var i=0;i&lt;arr.length;i++){                    if(arr.indexOf(arr[i]) != i){                        arr.splice(i,1); // 删除当前项                        i--; // 数组下标回退                    }                }                return arr;            }            var result = norepeat(arr);            console.log(result); // [1,2,3,5]            执行过程                arr.indexOf(arr[i])     i                        0                0                        1                1                        2                2                        0                3                            arr.splice(3,1) -&gt; [1,2,3,1,2,5] ==&gt; [1,2,3,2,5];                        0                3                            arr.splice(3,1) -&gt; [1,2,3,2,5] ==&gt; [1,2,3,5];                        3                3    concat()        连接两个字符串        var str1 = 'hello';        var str2 = 'world';        console.log(str1.concat(str2)); // 'helloworld'        也可以使用+拼接        console.log(str1 + str2); // 'helloworld'    slice(begin,end)        截取子字符串，begin开始位置，end结束位置，不包含结束位置        var str = 'helloworld';        console.log(str.slice(2,4)); // ll    trim()        删除字符串左右两边的空格        var str = ' hello world ';        console.log(str.trim()); // 'hello world'    toUpperCase()        转换为大小        var str = 'hello world';        console.log(str.toUpperCase()); // 'HELLO WORLD'    toLowerCase()        转换为小写        var str = 'HELLO WORLD';        console.log(str.toUpperCase()); // 'hello world'    match(regexp)        查找匹配的内容，返回值为数组，保存了所有匹配的内容        案例见正则表达式    split()        把字符串分割为字符串数组        使用了''            var str = 'hello';            var result = str.split('');            console.log(result); // ['h','e','l','l','o']        没使用''            var str = 'hello';            console.log(str.split()); // ['hello']</code></pre><p>14.Math对象<br>    Math.ceil()     向上舍入<br>    Math.floor()    向下舍入<br>    Math.round()    四舍五入<br>    Math.random()   随机数（0-1的小数）</p><pre><code>举例：    var num = 11.7    console.log(Math.ceil(num))    console.log(Math.floor(num))    console.log(Math.round(num))    console.log(Math.random())</code></pre><p>15.Date对象<br>    1、实例化日期对象<br>        var date = new Date()<br>        console.log(date)</p><pre><code>2、Date对象方法    var date = new Date()    getDate()        表示获取当前月的日期        console.log(date.getDate())    getFullYear()        表示获取当前年份        console.log(date.getFullYear())    getMonth()        表示获取当前月份（0表示1月，11表示12月）        console.log(date.getFullYear())        getDay()        返回一个星期中的某一天        console.log(date.getDay())    getHours()        返回小时        console.log(date.getHours())    getMinutes()        返回分钟        console.log(date.getMinutes())    getSeconds()        返回秒        console.log(date.getSeconds())    getTime()        返回距 1970 年 1 月 1 日之间的毫秒数        console.log(date.getTime())                时间戳            格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)            至            现在的总秒数    toLocaleString()        根据本地时间把 Date 对象转换为字符串，并返回结果        console.log(date.toLocaleString())</code></pre><p>17、高级面向对象技术<br>    目的：利用一种机制可以帮我们创建具有特殊功能的对象</p><pre><code>之前都是通过对象字面量或者构造函数创建创建单个对象    var obj = {        name:'xpf',        age:25,        gender:'male'        ...    }    现在有了一个对象obj，我需要再去创建一个对象obj2，并且里面的属性名一样，如何创建？    var obj2 = {        name:'xpf',        age:25,        gender:'male'        ...    }    var obj3 = {        ...    }问题：    创建多个相似对象的时候会产生很多冗余的代码为了解决这样的问题，人们开始寻找解决方法，也就是  能不能批量的创建对象？1) 封装/创建对象的过程【api的本质】    1. 工厂函数模式        提供一个函数，每调用一次该函数，返回一个对象            function factory(name1,age1,gender1){                var obj = {                    name:name1,                    age:age1,                    gender:gender1,                    sayMessage:function(){                        console.log(this.name,this.age,this.gender)                    }                }                return obj;            }            var obj1 = factory("xpf",25,'male'); // { name: 'xpf', age: 25, gender: 'male' }            var obj2 = factory("zhangsan",30,'female'); // {name:'zhangsan',age:30,gender: 'female'}            obj1.sayMessage(); // xpf 25 male            obj2.sayMessage(); // zhangsan 30 female            精简模式--&gt;            function factory(name1,age1,gender1){                return {                    name:name1,                    age:age1,                    gender:gender1,                    sayMessage:function(){                        console.log(this.name,this.age,this.gender)                    }                }            }            var obj1 = factory("xpf",25,'male'); // { name: 'xpf', age: 25, gender: 'male' }            var obj2 = factory("zhangsan",30,'female'); // {name:'zhangsan',age:30,gender: 'female'}            obj1.sayMessage(); // xpf 25 male            obj2.sayMessage(); // zhangsan 30 female            问题：现在创建的是两个'人'的对象，如果我想创建一个'人'和一只'狗'                function factory(name,age,gender){                    var obj = {                        name:name,                        age:age,                        gender:gender                    }                    return obj                }                var obj1 = factory('xpf',25,'male');                var obj2 = factory('小黑',3,'雄性');                console.log(typeof(obj1)); // object                console.log(typeof(obj2)); // object                是人是狗无法区分        解决：            解决了多个相似对象创建的时候，代码冗余问题        问题：            1) 类型无法细分 (由于使用了return{}，所以创建出来的所有obj都是Object类型)                虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即如何得知一个对象的类型)    2. 构造函数模式        内置构造函数            Object、Array、Date、Number、String、Boolean、RegExp        自定义构造函数            1、js中可以自定义构造函数，从而自定义对象类型的属性和方法            2、构造函数的首字母大写            function Person(){}            //'人'的构造函数            function Person(name,age,gender){                this.name = name;                this.age = age;                this.gender = gender;                this.words = function(){                    console.log('嘤嘤嘤')                }            }            var per1 = new Person('xpf',25,'male');            var per2 = new Person('zhangsan',30,'female');            console.log(per1); // Person {name:'xpf',age:25,gender:'male',sayName:[Function]}            console.log(per2); // Person {name:'zhangsan',age:30,gender:'female',sayName:[Function]}            per1.words(); // 嘤嘤嘤            //'狗'的构造函数            function Dog(name,age,gender){                this.name = name;                this.age = age;                this.gender = gender;                this.words = function(){                    console.log('汪汪汪')                }            }            var dog1 = new Dog('小红',2,'雌性');            var dog2 = new Dog('小黑',4,'雄性');            console.log(dog1); // Dog { name: '小红', age: 2, gender: '雌性', words: [Function] }            console.log(dog2); // Dog { name: '小黑', age: 4, gender: '雄性', words: [Function] }            dog1.words(); // 汪汪汪            dog2.words(); // 汪汪汪        现象：            1、构造函数首字母大写   ---&gt;   (规范)            2、没有显式地创建对象            3、将属性和方法赋值给了 this 对象            4、没有return语句        说明：使用new关键字调用构造函数创建对象实例，实际上执行了如下步骤(构造函数的执行流程)  --  隐式            1、创建一个新对象            2、将构造函数的作用域赋值给这个对象(this指向该对象)            3、执行构造函数中的代码(给新对象添加属性与方法)            4、返回一个新对象        区别：构造函数与普通函数的区别            1、构造函数也是一个普通函数，创建方式和普通函数一样(函数声明)，但构造函数习惯上首字母大写            2、调用方式不一样                普通函数的调用方式：直接调用 person();                 构造函数的调用方式：需要使用new关键字来调用 new Person();            3、返回值不一样                普通函数：因为没有返回值，所以为undefined                    function person(){                    }                    var per = person();                    console.log(per); // undefined                构造函数：构造函数会马上创建一个新对象，并将该新对象作为返回值返回                    function Person(){                    }                    var per = new Person();                    console.log(per); // Person {}        解决：            解决了工厂函数模式遗留的类型细分问题        问题：            1) 函数会重复创建/破解封装性                每个方法都要在每个实例上重新创建一次，也就是每次调用构造函数的时候，都会创建一个对象，而对象中又会每次去创建一个words方法(函数)                期望将这个方法提取出来        最终解决方案    3. 构造函数模式与原型相结合模式        属性保存在实构造函数中，方法保存在构造函数原型中            function Dog(name,age,gender){                this.name = name;                this.age = age;                this.gender = gender;            }            Dog.prototype.words = function(){                console.log('汪汪汪')            }            var dog1 = new Dog('小红',2,'雌性');            var dog2 = new Dog('小黑',4,'雄性');            console.log(dog1);            console.log(dog2);            dog1.words(); // 汪汪汪            console.log(dog1.words === dog2.words); // true2) 继承    当我们创建一个构造函数时，构造函数会获得一个prototype属性，该属性是一个指针，指向一个原型对象，原型对象包含一个constructor属性，该属性也是一个指针，指向构造函数，而当我们创建构造函数的实例时，该实例其实会获得一个[[Prototype]]属性，指向原型对象    1. 原型链继承 (子构造函数的原型指向父构造函数的实例)        原理：让一个引用类型继承另一个引用类型的属性和方法        有钱人Person1            function Person1(name,age,gender){                this.name = name;                this.age = age;                this.gender = gender            }            Person1.prototype.money = function(){                console.log('我有很多钱');            }            var person1 = new Person1('xpf',25,'male');            person1.money();            console.log(person1);            var person2 = new Person1('zhangsan',12,'female');            person2.money();            console.log(person2);        没钱Person2(没money方法)            function Person2(name,age,gender){                this.name = name;                this.age = age;                this.gender = gender;            }            var person2 = new Person2('zhangsan',30,'male');            person2.money(); // 报错            console.log(person2);            此时，Person2创建出来的实例都无法调用money方法，否则报错            Person2家里的孩子无法用Person1家里的钱，否则会报警            第一步(不加Person2.prototype.constructor = Person2)                function Person1(name,age,gender){                    this.name = name;                    this.age = age;                    this.gender = gender                }                Person1.prototype.money = function(){                    console.log('我有很多钱');                }                var person1 = new Person1('xpf',25,'male');                person1.money();                console.log(person1); // Person1 { name: 'xpf', age: 25, gender: 'male' }                Person2.prototype = new Person1();                function Person2(name,age,gender){                    this.name = name;                    this.age = age;                    this.gender = gender;                }                var person2 = new Person2('zhangsan',30,'male');                person2.money();                console.log(person2); // Person1 { name: 'zhangsan', age: 30, gender: 'male' }                此时，Person2家的孩子变成了Person1家的孩子            第二步                function Person1(name,age,gender){                    this.name = name;                    this.age = age;                    this.gender = gender                }                Person1.prototype.money = function(){                    console.log('我有很多钱');                }                var person1 = new Person1('xpf',25,'male');                person1.money();                console.log(person1); // Person1 { name: 'xpf', age: 25, gender: 'male' }                Person2.prototype = new Person1();                Person2.prototype.constructor = Person2;                function Person2(name,age,gender){                    this.name = name;                    this.age = age;                    this.gender = gender;                }                var person2 = new Person2('zhangsan',30,'male');                person2.money();                console.log(person2); // Person2 { name: 'zhangsan', age: 30, gender: 'male' }    2. 借用构造函数 (不仅可以继承方法，也可以继承属性)        Person1.call(this,name,age)        function Person1(name,age,gender){            this.name = name;            this.age = age;            this.gender = gender        }        Person1.prototype.money = function(){            console.log('我有很多钱');        }        var person1 = new Person1('xpf',25,'male');        person1.money();        console.log(person1);        Person2.prototype = new Person1();        Person2.prototype.constructor = Person2;        function Person2(name,age,gender,weight){            //此处，调用了Person1函数，将当前Person2函数的this传递给了Person1            //也就是Person1内部的this指向了Person2            Person1.call(this,name,age,gender);            this.wieght = weight;        }        var person2 = new Person2('zhangsan',30,'male',130);        person2.money();        console.log(person2);</code></pre><p>18、DOM（js操作html的api）<br>    1) DOM构造函数树<br>        </p><div>hello</div><p></p><pre><code>    Node(节点)        文档节点    Document类型            *元素节点 Element类型    &lt;div&gt;&lt;/div&gt;        文本节点 Text类型        hello        注释节点 Comment类型 &lt;!--注释--&gt;2) 实例化（如何创建对象）        var one = document.getElementById("one");3) API(在线文档) 火狐 mdn    1. Document        文档，表示整个html文档，一般情况下一个html可以使用一个Document的实例来表示，即document        属性            documentElement    HTML页面中的&lt;html&gt;元素            body            HTML页面中的&lt;body&gt;元素            head            HTML页面中的&lt;head&gt;元素            title            HTML页面中的title内容        方法：            getElementById()            getElementsByClassName()            getElementsByTagName()            getElementsByName()        window.onload = function(){            var dom = document            var dom1 = document.getElementById('one')            var dom2 = document.getElementsByClassName('myDiv')[0]            var dom3 = document.getElementsByTagName('div')[0]            var dom4 = document.getElementsByName('xx')[0]            console.log(dom)            console.log(dom.body)            console.log(dom.head)            console.log(dom.title)            console.log(dom1)            console.log(dom2)            console.log(dom3)            console.log(dom4)        }    2. Element【*】        元素/标签            body/div/p/span/table/form...        属性            1) 元素属性                    id                    name                    href                    src                    alt                    target                    style                        获取或设置一个元素的样式                    &lt;img src="xxx" alt="" style="color:red"&gt;                    var img = document.getElementsByTagName('img')[0];                    console.log(img.src)                    console.log(img.style)            2) 元素层次结构                innerHTML                    获取或设置一个元素内的html内容，包含换行                innerText                    获取或设置一个元素内的文本内容                &lt;div id="one"&gt;hello&lt;/div&gt;                var dom = document.getElementById('one')                //dom.innerText = 'xpf';                //dom.style.color = 'red';                console.log(dom.innerHTML)                console.log(dom.innerText)        方法(与属性相关)            getAttribute(属性名)                返回指定的属性值                &lt;div style="color: red;" name="xxx" class="myDiv" id="one"&gt;&lt;/div&gt;                var dom = document.getElementsByClassName('myDiv')[0]                console.log(dom.getAttribute('name'))                console.log(dom.getAttribute('id'))                console.log(dom.getAttribute('class'))                console.log(dom.getAttribute('style'))            setAttribute(属性名,属性值)                把指定属性设置或修改为指定的值，注意，该方法并没有返回值                    原本存在的时候，为修改                    原本不存在的时候，为设置                window.onload = function(){                    var dom4 = document.getElementsByName('xx')[0]                    console.log(dom4.getAttribute('class'))                    //修改之前                    console.log(dom4)                    //修改                    console.log(dom4.setAttribute('class','ss')); // undefined                    //修改之后                    console.log(dom4)                }            querySelector(选择器)                返回文档中匹配指定 CSS 选择器的第一个元素            querySelectorAll(选择器)                返回文档中匹配指定 CSS 选择器的所有元素                window.onload = function(){                    var dom = document.querySelector('.myDiv')                    console.log(dom); // 只返回第一个类名为myDiv的div                }                &lt;div id="one" class="myDiv" name='xx'&gt;hello&lt;/div&gt;                &lt;div id="one" class="myDiv" name='xx'&gt;hello&lt;/div&gt;                &lt;div id="one" class="myDiv" name='xx'&gt;hello&lt;/div&gt;                &lt;div id="one" class="myDiv" name='xx'&gt;hello&lt;/div&gt;                window.onload = function(){                    var dom = document.querySelectorAll('.myDiv')                    console.log(dom); // 返回所有类名为myDiv的div                }                &lt;div id="one" class="myDiv" name='xx'&gt;hello&lt;/div&gt;                &lt;div id="one" class="myDiv" name='xx'&gt;hello&lt;/div&gt;                &lt;div id="one" class="myDiv" name='xx'&gt;hello&lt;/div&gt;                &lt;div id="one" class="myDiv" name='xx'&gt;hello&lt;/div&gt;    3. Text        文本内容,如下"hello world"表示文本内容        &lt;div&gt;hello world&lt;/div&gt;        4. Comment        注释，如下        &lt;!-- 注释内容 --&gt;    案例一：图片切换        btn.onclick = function(){            if(img.src == './js2.jpg'){                img.src = './js3.jpg'            } else {                img.src = './js2.jpg'            }        }        ===&gt;        btn.onclick = function(){            if(img.getAttribute('src') == './js2.jpg'){                img.src = './js3.jpg'            } else {                img.src = './js2.jpg'            }        }    4) 节点操作    1、节点创建        document.createElement('标签名')        document.createElement('div')表示创建了一个标签为div的节点        window.onload = function(){            //获取父节点            var parent = document.getElementsByClassName('parent')[0];            //创建新节点            var newChild = document.createElement('div')            //给新节点设置内容            newChild.innerText = '新节点'            //将新节点追加到父节点后面            parent.appendChild(newChild)        }    2、节点的追加        &lt;div class="parent"&gt;            &lt;div class="child"&gt;item1&lt;/div&gt;            &lt;div class="child"&gt;item2&lt;/div&gt;            &lt;div class="child"&gt;item3&lt;/div&gt;            &lt;div class="child"&gt;item4&lt;/div&gt;        &lt;/div&gt;        1) parent.appendChild(newChild)            将节点追加到parent的最后，追加的可以是自己新创建的节点，也可以是原本已存在的节点            注意：                任何DOM节点不能同时出现在文档中的多个位置                ==&gt;                 如果追加的节点为原本已存在的，只会改变该节点的位置            window.onload = function(){                var parent = document.getElementsByClassName('parent')[0];                var item1 = document.getElementsByClassName('child')[0];                parent.appendChild(item1);            }        2) parent.insertBefore(newChild,item1)            第一个参数为要插入的节点            第二个参数为要插入的位置            window.onload = function(){                var parent = document.getElementsByClassName('parent')[0];                var item1 = document.getElementsByClassName('child')[1];                var newChild = document.createElement('div')                newChild.innerText = '新节点'                parent.insertBefore(newChild,item1)            }    3、节点的删除        parent.removeChild(item1)        window.onload = function(){            var parent = document.getElementsByClassName('parent')[0];            var item1 = document.getElementsByClassName('child')[1];            parent.removeChild(item1)        }    4、节点的复制(克隆)        1) 浅复制            cloneNode() / cloneNode(false)            默认为浅复制，只复制标签            window.onload = function(){                var parent = document.getElementsByClassName('parent')[0];                var item1 = document.getElementsByClassName('child')[0];                var clone_node = item1.cloneNode()                parent.appendChild(clone_node)            }        2) 深复制            cloneNode(true)            传递参数true，复制标签及内容            window.onload = function(){                var parent = document.getElementsByClassName('parent')[0];                var item1 = document.getElementsByClassName('child')[0];                var clone_node = item1.cloneNode(true)                parent.appendChild(clone_node)            }</code></pre><p>19、事件<br>    1) 事件三要素<br>        1. 事件目标<br>            获取事件源<br>        2. 事件处理程序<br>            为事件源绑定事件处理函数，当绑定的事件类型被触发的时候该函数执行</p><pre><code>        事件类型：            click 、focus 、blur 、submit 、mouseover 、mouseout 、...    3. 事件对象        当事件处理函数执行的时候，dom会将事件对象传递给事件处理函数        可以用event接收2) 事件流    描述的是从页面中接收事件的顺序    'DOM2级事件'规定了事件流包括三个阶段：事件捕获阶段，处理目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后是事件冒泡。      事件捕获： document-&gt;html-&gt;body        处理目标： 事件处理      事件冒泡： div-&gt;body-&gt;html-&gt;document    1. 事件冒泡（默认事件执行顺序）        含义：            事件开始由最具体的元素接收，然后逐级向上传播到不具体的节点        特点：            从内往外        前提条件：            1. 元素需要嵌套            2. 每层元素上都绑定了事件        &lt;div id="outer"&gt;            &lt;div id="center"&gt;                &lt;div id="inner"&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;        var outer = document.getElementById('outer');        var center = document.getElementById('center');        var inner = document.getElementById('inner');        outer.onclick = function(){            console.log(this)        }        center.onclick = function(){            console.log(this)        }        inner.onclick = function(){            console.log(this)        }        1、阻止事件冒泡            event.stopPropagation()            inner.onclick = function(){                console.log(this)                event.stopPropagation();            }        2、当前点击的事件对象            event.target            outer.onclick = function(){                console.log(this)                console.log(event.target)            }            center.onclick = function(){                console.log(this)                console.log(event.target)            }            inner.onclick = function(){                console.log(this)                console.log(event.target)            }    2. 事件捕获        含义：            不太具体的DOM节点应该更早接收到事件，而最具体的节点应该最后接收到事件        特点：            从外往内        参数：            第一个参数是 事件的类型(click、mouseover)            第二个参数是 事件处理函数            第三个参数是 布尔值，用于描述事件是冒泡还是捕获，该参数是可选的，默认为false                true    -&gt;        事件捕获                false    -&gt;        事件冒泡        outer.addEventListener('click',function(){            console.log(this)        },true)        center.addEventListener('click',function(){            console.log(this)        },true)        inner.addEventListener('click',function(){            console.log(this)        },true)3) 事件绑定方式    1. onxxx        属性        简单，兼容性比较好        outer.onclick = function(){            console.log(this)        }        outer.onmouseover = function(){            console.log(this)        }    2. addEventListener        方法        outer.addEventListener('click',function(){            console.log(this)        })        outer.addEventListener('mouseover',function(){            console.log(this)        })    3. attachEvent        方法        IE低版本下才能兼容4) 事件类型    click     鼠标点击    scroll    页面滚动        var two = document.getElementById('two');        document.onscroll = function(){            console.log(document.body.scrollTop)        }    keyup    键盘抬起    keydown    键盘落下        当键盘事件发生时，event对象的keyCode属性中包含一个代码与键盘上的特定键对应        keydown        按下键盘任意键时触发，如果按住不放会重复触发该事件        keypress    按下键盘字符键时触发，如果按住不放会重复触发该事件        document.onkeydown = function(){            console.log(event.keyCode)        }        var input = document.getElementsByTagName('input')[0]        input.onkeydown = function(){            if(event.keyCode == 13){                alert('请输入正确的用户名密码！')            }        }    focus    聚焦    blur    失焦    mouseover    光标移动到元素上，支持子元素    mouseout    光标移出元素，支持子元素     mouseenter    光标移动到元素上，不支持子元素    mouseleave    光标移出元素，不支持子元素    onload        window.onload 当前页面中的内容加载完毕    案例一：        实现历史记录的功能        使用mouserenter    案例二：        页面滚动到某一位置再显示节点    5) 事件代理    用法：        将事件绑定在当前元素的父元素上而非当前元素上，这时候当点击当前元素的时候，执行父元素上绑定的事件处理函数，可以通过event.target获取当前元素    好处：        父元素代理子元素所有的事件，子元素可以动态添加和删除而不用频繁绑定事件    案例：        没使用事件代理：            需求一：实现光标移入li时，给当前li添加背景色，其他li没有背景色            思路：将所有的li获取到(类数组)，转换为数组，然后遍历数组的每一项(即每一个li)，给每一项绑定事件        var li = document.getElementsByTagName('li');        var liList = Array.prototype.slice.call(li,0)        liList.forEach(function(item,index){            //移入时，添加背景色            item.onmouseenter = function(){                event.target.style.background = 'red'            }            //移出时，去掉背景色            item.onmouseleave = function(){                event.target.style.background = 'none'            }        })        需求二：并且，在给ul新添加li的情况下，新增的li也要有如上功能            使用事件代理        问题代码:            var li = document.getElementsByTagName('li');            var liList = Array.prototype.slice.call(li,0)            liList.forEach(function(item,index){                item.onmouseenter = function(){                    event.target.style.background = 'red'                }                item.onmouseleave = function(){                    event.target.style.background = 'none'                }            })                        var btn = document.getElementById('btn');            var ul = document.getElementsByTagName('ul')[0];            btn.onclick = function(){                var newLi = document.createElement('li')                ul.appendChild(newLi)            }            新增的li没有绑定事件        正确代码：事件代理            var ul = document.getElementsByTagName('ul')[0];            ul.onmouseover = function(){                // console.log(event.target)                if(event.target.nodeName == 'LI'){                    event.target.style.background = 'red'                }            }            ul.onmouseout = function(){                // console.log(event.target)                if(event.target.nodeName == 'LI'){                    event.target.style.background = 'none'                }            }            var btn = document.getElementById('btn');            btn.onclick = function(){                var newLi = document.createElement('li')                ul.appendChild(newLi)            }                </code></pre><p>20、BOM(浏览器对象模型)<br>    使用JavaScript来访问和控制浏览器对象实例<br>    1) 超时调用<br>        含义：<br>            在指定的毫秒数后调用函数<br>        参数：<br>            第一个参数是         要执行的代码(必需)<br>            第二个参数是        以毫秒表示的时间(可选，默认为0)<br>                1000毫秒 = 1秒<br>        返回值：<br>            返回一个 ID（数字），可以将这个ID传递给 clearTimeout() 来取消执行<br>        语法：<br>            var id = setTimeout(function(){},time)</p><pre><code>        window.onload = function(){            setTimeout(function(){                console.log(1)            },1000)        }    清除：        clearTimeout(id)2) 间歇调用    含义：        按照指定的周期（以毫秒计）来调用函数，该方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭    参数：        第一个参数是         要执行的代码(必需)        第二个参数是        以毫秒表示的时间(必需)    返回值：         返回一个 ID（数字），可以将这个ID传递给clearInterval()来取消执行    语法：        var id = setInterval(function(){},time)        window.onload = function(){            var id = setInterval(function(){                console.log(1)            },1000)        }    清除：        clearInterval(id)    案例一：        根据栏目名查询栏目信息        findByName(){            var name = this.list[0].name            axios.get('http://47.106.244.1:8099/manager/category/findCategoryByCategoryname?name='+name).then((res)=&gt;{                console.log(res.data.data)            })        }    案例二：        实现点名            var div = document.getElementsByTagName('div')[0]            var arr = ['张三','李四','王五']            var id = setInterval(function(){                var index = Math.round(Math.random()*(arr.length-1))                div.innerText = arr[index]            },10)            var btn = document.getElementsByTagName('button')[0]            btn.onclick = function(){                clearTimeout(id)            }3) 系统对话框    alert()        警告框，会阻塞代码的执行，该方法接受一个字符串并显示给用户，无返回值        var result = alert(); // undefined    confirm()        确认对话框，显示一个'确定'和'取消'按钮，点击'确定'后，返回true        var result = confirm();            确定        true            取消     false    prompt()        会话框，提示用户输入一些文本，显示一个'确定'和'取消'按钮，点击'确定'后，返回用户输入的文本        var result = prompt();            确定        用户输入文本/空字符串            取消     null4) Location对象    包含有关当前 URL 的信息        1. 属性            host                返回一个URL的主机名和端口            href                返回完整的URL            port                返回一个URL服务器使用的端口号            window.onload = function(){                console.log(location)                console.log(location.host)                console.log(location.href)                console.log(location.port)            }        2. 方法            assign(url)                载入一个新的url，并在浏览记录中生成一条记录(可以回退)            replace()                用新的url替换当前的url，不会在浏览记录中生成一条记录(不可以回退)            reload()                重新载入当前的文档(刷新)            window.onload = function(){                var btn = document.getElementsByTagName('button')[0]                btn.onclick = function(){                    location.assign('https://www.runoob.com/jsref/obj-location.html')                }            }        ---&gt;            window.open(url)                新打开一个页面            window.open('文件部署地址')                可以下载一个文件5) 存储对象    浏览器提供了sessionStorage(会话存储)和localStorage(本地存储)两个存储对象来对网页的数据进行添加、删除、修改、查询操作    localStorage         用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除    sessionStorage         用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据    方法：        getItem(key)        返回指定键的值        setItem(key, value)    添加键和值，如果对应的值存在，则更新该键对应的值        removeItem(key)        移除键        clear()                清除存储对象中所有的键        情况一：存储单个键值对            window.onload = function(){                var btn1 = document.getElementById('btn1')                var btn2 = document.getElementById('btn2')                var btn3 = document.getElementById('btn3')                localStorage.setItem('token',111)                localStorage.setItem('username','xpf')                btn1.onclick = function(){                    var token = localStorage.getItem('token')                    console.log(token)                }                btn2.onclick = function(){                    localStorage.removeItem('token')                }                btn3.onclick = function(){                    localStorage.clear()                }            }        情况二：存储一个对象            window.onload = function(){                var btn1 = document.getElementById('btn1')                var obj = {                    name:'xpf',                    password:123321                }                localStorage.setItem('userInfo',JSON.stringify(obj))                btn1.onclick = function(){                    var token = localStorage.getItem('userInfo')                    console.log(JSON.parse(token))                }            }    案例：登录案例        用户发起登录请求 -&gt; 账号密码正确时返回token令牌 -&gt; 用户将后台返回的token存储到浏览器中 -&gt; 根据token查询用户基本信息 -&gt; 将查询到的基本信息存储到浏览器 -&gt; 根据id查询用户详细信息        用户名：&lt;input type="text" v-model='form.username'&gt;        密码：&lt;input type="text" v-model='form.password'&gt;        &lt;button @click="toLogin"&gt;登录&lt;/button&gt;        &lt;button @click="findUser"&gt;获取用户基本信息&lt;/button&gt;        &lt;button @click="findUserDetail"&gt;根据id查询用户详细信息&lt;/button&gt;        toLogin(){            axios.post('http://47.106.244.1:8099/manager/user/login',this.form).then((res)=&gt;{                console.log(res.data.data)                localStorage.setItem('token',res.data.data.token)            })        },        findUser(){            var token = localStorage.getItem('token')            console.log(token)            axios.get('http://47.106.244.1:8099/manager/user/info?token='+token).then((res)=&gt;{                console.log(res.data.data)                localStorage.setItem('info',JSON.stringify(res.data.data))            })        },        findUserDetail(){            var id = JSON.parse(localStorage.getItem('info')).id            axios.get('http://47.106.244.1:8099/manager/user/findUserById?id='+id).then((res)=&gt;{                console.log(res.data.data)            })        }</code></pre><p>补充：<br>    1.<br>        function fn(val){<br>        　val+=10;<br>        　return val;<br>        }<br>        var val = 10;<br>        var result = fn(val);<br>        console.log(val);<br>        console.log(result);</p><pre><code>2.    function fn(obj){         obj.name = "larry";     }    var obj = new Object();     obj.name = "tom";       fn(obj);     console.log(obj.name);3.    function setName(obj) {        obj.name = 'tom';        obj = {            name:'terry'        }        console.log(obj.name);    }    var person = {        name:'larry'    }    setName(person);    console.log(person.name);</code></pre><p>补充：<br>    任何函数都是Function的实例<br>    =&gt;Object也是Function的实例，Function也是Function的实例</p><pre><code>任何对象都是Object的实例=&gt;Function也是Object的实例</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="2021/06/03/css/"/>
      <url>2021/06/03/css/</url>
      
        <content type="html"><![CDATA[<p>css<br>1、入门<br>    1) 什么是css<br>        层叠样式表，用于修饰页面元素【人靠衣装马靠鞍，狗配铃铛跑的欢】</p><pre><code>    层叠        多个样式表修饰同一个元素    样式表(声明块)        {            color:#fff;        }2) css语法    选择器 {        样式名:样式值;        样式名:样式值;        ...    }3) css可读性【MDN】    1. 空白字符        空格、tab字符和换行        .class {            color:'red';            font-size:18px;        }    2. 注释  ctrl + /        /* 注释 */        作用：             解释说明，便于代码维护和管理    3. 速写        padding-top:5px;        padding-right:10px;        padding-bottom:15px;        padding-left:20px;        ==&gt;等价于        padding: 5px 10px 15px 20px;    4. 选择器组        .one , .two , .three {            color:'red';        }4) 在html中如何应用css    1. 内部style标签【内部样式表】        将样式添加到head标签中的style标签里        &lt;style&gt;&lt;/style&gt;    2. 内联style属性【内联样式表】        在元素中添加style属性        &lt;div style="width:100px;height:100px;"&gt;&lt;/div&gt;    3. 外部link导入【外部样式表】        将样式单独抽离出来，写成一个css文件，在head标签中通过link标签导入        &lt;link rel="stylesheet" href=""&gt;    4. @import导入        将样式单独抽离出来，写成一个css文件，在style标签内通过@import导入路径        &lt;style&gt;            @import './test.css';        &lt;/style&gt;        link和@import的区别        1) 所属范围            @import 是css的语法，只能导入样式            link是html的标签，不仅可以加载样式，还可以定义rel属性                rel="stylesheet"表示调用外部样式表        2) 加载顺序            页面加载的时候，link标签引入的css被同时加载            @import引入的css在页面加载完毕后再被加载        3) 兼容性            @import需要兼容IE5+            link标签，不存在兼容性问题</code></pre><p>2、选择器<br>    1) 基本选择器<br>        标签选择器<br>            含义：根据指定的标签名，在当前文件中找到所有该名称的标签，设置属性<br>            格式：<br>                标签名 {<br>                    样式名:样式值<br>                }<br>            注意：<br>                1. 标签选择器选中的是当前文件中所有的标签, 而不能单独选中某一个标签<br>                2. 标签选择器无论标签藏得多深都能选中<br>                3. 只要是HTML中的标签就可以作为标签选择器</p><pre><code>    类选择器        含义: 根据指定的类名找到对应的标签, 设置属性        格式:            .类名{                属性:值;            }        注意:            1. 在同一个文件中的class可以重复            2. 使用class选择器时要在class前面加上.            3. 类名的命名规范和id名称的命名规范一样            4. 在HTML中每个标签可以同时绑定多个类名                格式:                &lt;div class="类名1 类名2 ..."&gt;&lt;/div&gt;                错误的写法:                &lt;p class="para1" class="para2"&gt;&lt;/p&gt;    id选择器        含义：根据指定的id找到对应的标签，设置属性        格式：            #id {                样式名:样式值            }        注意：            1. 在同一个文件中的id不可以重复            2. 使用id选择器时要在id前面加上#            3. id有一定的规范                id的名称只能由字母/数字/下划线                    a-z 0-9 _                id名称不能以数字开头                id名称不能是HTML标签的名称    逗号选择器        含义: 同时给多个选择器选中的标签设置属性        格式:            选择器1,选择器2{                样式名:样式值            }        注意:            1. 逗号选择器使用,来连接            2. 选择器可以使用 标签名称、id、class    组合选择器【了解】        含义: 给同时具备多个选择器的标签设置属性        格式:            选择器1选择器2{                样式名:样式值;            }        注意:            1. 选择器和选择器之间没有任何的连接符号            2. 选择器可以使用 标签名称、id、class                普遍选择器        含义: 给当前文件所有的标签设置属性        格式:            * {                样式名:样式值;            }        2) 层次选择器    子代选择器        含义: 找到指定标签中所有的直接子元素, 设置属性        格式:            标签名称1&gt;标签名称2{                样式名:样式值;            }        先找到所有名称叫做"标签名称1"的元素, 然后在这个标签中查找所有第一代子元素名称叫做"标签名称2"的元素        注意:            1. 子元素选择器只会查找第一代子元素, 不会查找被嵌套的元素            2. 子元素选择器之间需要用 &gt; 连接    后代选择器        含义: 找到指定标签的所有的后代元素, 设置属性        格式:            标签名称1 标签名称2{                样式名:样式值;            }        先找到所有名称叫做"标签名称1"的元素, 然后再在这个元素下面去查找所有名称叫做"标签名称2"的元素, 然后在设置属性        注意:        1. 后代选择器必须用空格隔开        2. 后代不仅仅是儿子, 也包括孙子/重孙子, 只要最终是放到指定标签中的都是后代    兄弟选择器        1. 相邻兄弟选择器            含义: 给指定选择器后面紧跟的那个选择器选中的标签设置属性            格式:                选择器1+选择器2{                    属性:值;                }            注意:            1.相邻兄弟选择器必须通过+连接            2.相邻兄弟选择器只能选中紧跟其后的那个标签, 不能选中被隔开的标签        2. 通用兄弟选择器            含义: 给指定选择器后面的选择器选中的所有标签设置属性            格式:                选择器1~选择器2{                    属性:值;                }            注意:            1.通用兄弟选择器必须用~连接            2.通用兄弟选择器选中的是指定选择器后面某个选择器选中的所有标签, 无论有没有被隔开都可以选中3) 属性选择器    含义: 根据指定的属性名称找到对应的标签, 然后设置属性    格式:        [attribute]            找到所有具有该属性名的标签, 设置属性        [attribute=value]            找到所有属性值为value的标签, 设置属性        [attribute^=value]            找到所有以value开头的标签, 无论有没有被-隔开        [attribute$=value]            找到所有以value结尾的标签        [attribute~=value]            找到拥有独立value的标签, value不可以和其他属性连接        [attribute*=value]            只要包含value就可以找到    最常见的应用场景, 用于区分input        input[type=password] {        }        &lt;input type="text"&gt;        &lt;input type="password"&gt;        &lt;input&gt;4) 伪类选择器    在选择器的后面使用: 用于添加特殊的效果    1. 与子元素相关        :first-child    选中同级别中的第一个标签        :last-child        选中同级别中的最后一个标签        :nth-child(n)    选中同级别中的第n个标签            数字            字符                odd                even                    &lt;p&gt;段落一&lt;/p&gt;        &lt;p&gt;段落二&lt;/p&gt;        &lt;p&gt;段落三&lt;/p&gt;        &lt;ul&gt;            &lt;li&gt;                &lt;p&gt;段落四&lt;/p&gt;                &lt;p&gt;段落五&lt;/p&gt;            &lt;/li&gt;        &lt;/ul&gt;    2. 与状态相关        :link          未访问的链接        :hover         鼠标悬浮时的元素        :active     激活链接        :visited     已访问的链接        :focus        聚焦时5) 伪元素选择器    在选择器的后面使用:: 用于添加元素    ::after            ::before6) 选择器优先级【级联】    1. !important        优先级最高，不推荐    2. 特性值        1000            内联style属性        100            id                       10            类名选择器、伪类选择器、属性选择器        1            标签选择器、伪元素选择器    3. 代码顺序        如果样式具有相同的特性值，则看代码顺序，样式离元素近的优先级更高</code></pre><p>3、字体样式、文本样式、列表样式<br>    1) 字体样式 font- (可以被继承)<br>        color<br>        font-style    字体斜体<br>            normal    不开启斜体<br>            italic    开启斜体<br>        font-weight    字体粗细<br>            normal    正常字体<br>            bold    粗的字体<br>            bolder<br>            lighter    更细的字体<br>            100~900    400等同于normal，700等同于bold<br>        font-size    字体大小<br>            浏览器默认字体为16px<br>        line-height    行高<br>            可设置文本垂直居中<br>            设置的值为当前文本的父元素的高度即可垂直居中<br>        font-family    字体族，提供可选字体列表，当用户电脑没有某个字体时，依次查找列表中的字体<br>            取值：指定字体族名称<br>            “微软雅黑”<br>            “Microsoft YaHei”<br>            “宋体”<br>            serif 衬线字体<br>            sans-serif 无衬线字体<br>            fangsong 一种汉字字体，介于宋体和楷体之间。这种字体常用于某些政府文件</p><pre><code>    速写        1. 必须包含font-size、font-family        2. font-style、font-weight必须在font-size之前        3. font-family必须在最后        font:font-style font-weight font-size font-family;        例如：italic bold 12px 'Microsoft YaHei',serif;        2) 文本样式 text- (可以被继承)    text-align    内容相对于它的块级父元素的对齐方式        left 左对齐        center 居中对齐        right 右对齐        justify    两侧对齐    text-decoration 文本修饰线        underline 下划线        overline    上划线        line-through 贯穿线(删除线)    text-indent 首行缩进        px        em        %    text-shadow 文本阴影        px    x轴偏移量        px    y轴偏移量        blur    模糊距离        color    阴影颜色    text-transform 字体改变        lowercase    小写        uppercase    大写        capitalize    首字母大写3) 列表样式    list-style-type    列表标志类型        disc    实心圆点 (默认值)        circle    空心圆点        square    实心方块        ...    list-style-image 列表标志        url('')    list-style-position 列表标志的位置        outside        inside    list-style 速写【顺序没有影响】        type        image        postition4) 拓展    1. 文字水平、垂直居中        水平：text-align:center;        垂直：line-height:父元素高度;    2. 子元素在父元素中水平垂直居中        父元素display:table-cell; vertical-align:middle;text-align: center;        子元素display:inline-block;    3. 消除a标签默认样式        text-decoration:none;        color:#333;        cursor:default;            help            pointer            wait            ...</code></pre><p>4、css单位<br>    1) 颜色<br>        1. 关键字<br>            red、orange、yellow…<br>            color:red;<br>        2. 十六进制<br>            #333333 ==&gt; #333<br>            color:#333;<br>        3. rgb函数<br>            r 红色<br>            g 绿色<br>            b 蓝色<br>            color:rgb(0,0,0);<br>        4. rgba函数<br>            r 红色<br>            g 绿色<br>            b 蓝色<br>            a 此颜色的透明度 0~1<br>            color:rgba(0,0,0,0.5);<br>        5. 渐变色<br>            background-image: linear-gradient(to right,red,yellow);</p><pre><code>    拓展：父元素设置透明度，如何不影响到子元素？        父元素使用rgba设置透明度        opacity会影响子元素的透明度2) 长度    1. 绝对单位        px    2. 相对单位        em                1em = 当前元素上的font-size的值            font-size:16px;            1em = 16px;            2em = 32px;        rem 相对于根元素html            html{font-size:14px}            1rem = 14px;        %            相对于父元素</code></pre><p>5、网络字体(字体图标库的使用)<br>    1) webfont    <a href="http://www.xiazaiziti.com/tag/ttf?btwaf=17865710">http://www.xiazaiziti.com/tag/ttf?btwaf=17865710</a><br>        1. 下载对应的字体，如此处的ttf字体<br>        2. 将下载好的字体文件放到对应的目录<br>        3. 在style标签中引入<br>            @font-face {<br>                font-family: ‘随意’;<br>                src: url(‘./HYXinHaiXingKaiW.ttf’);<br>            }<br>        4. 在需要使用字体的文本的标签加上font-family即可<br>            .test {<br>                font-family:’随意’;<br>            }</p><pre><code>2) 字体图标库iconfont、fontawesome    iconfont        1.加购 -&gt; 添加至项目 -&gt; 生成在线链接        2.复制在线css代码到icon.css(自己新建)        3.使用&lt;i class="iconfont 图标名"&gt;&lt;/i&gt;        fontawesome        1. 在bootcdn中搜索fontawesome，引入link到页面        2. 使用&lt;i class="fa fa-user-circle"&gt;&lt;/i&gt;        或者        1.下载离线fontawesome        2.引入离线包（所有）        3.使用&lt;i class="fa fa-user-circle"&gt;&lt;/i&gt;</code></pre><ol start="6"><li><p>盒子模型</p><ol><li><p>盒子属性<br> width<br> height<br> margin</p><pre><code> margin-top margin-right margin-bottom margin-left margin     margin:10px;        上右下左         margin:0 10px;     上下为0，左右10px     margin:0 5px 10px;     上0，左右5px，下10px     margin:0 5px 10px 15px;     上右下左    </code></pre><p> border</p><pre><code> border-width     边框宽度 border-style     边框线类型     solid    实线     dotted    点     dashed    虚线     double    双实线 border-color     边框线颜色 border-radius    边框圆角 速写     border:1px solid #333;</code></pre><p> padding</p><pre><code> padding-top padding-right padding-bottom padding-left</code></pre><p> box-shadow</p><p> background-color    背景颜色<br> background-image    背景图片<br> background-repeat     背景重复方式</p><pre><code> repeat-x repeat-y no-repeat</code></pre><p> background-size        背景图片大小</p><pre><code> background-size:100% 100%;</code></pre><p> 一个盒子的组成</p><pre><code> width、padding、border、margin</code></pre></li><li><p>盒子分类<br> 盒子可以通过box-sizing来设置分类</p><ol><li><p>内容盒子【W3C标准盒子】【默认】<br> box-sizing:content-box;</p><p> width = 内容宽<br> 所占的宽 = width + padding + border + margin</p></li><li><p>边框盒子【IE盒子】<br> box-sizing:border-box;</p><p> width = 内容宽 + padding + border<br> 所占宽 = width + margin</p></li></ol><p> margin:20px,border:10px,padding:10px;width:200px;分别计算两种盒子模型下所占的宽</p><p> 内容盒子</p><pre><code> 所占的宽 = width + padding + border + margin         = 200 + 10*2 + 10*2 + 20*2         = 280px</code></pre><p> 边框盒子</p><pre><code> 所占的宽 = width + margin         = 200 + 20*2         = 240px</code></pre><p> margin重叠【margin塌陷】</p><pre><code> 两个盒子上下排布，竖直方向的margin不叠加，只取较大的值作为两个盒子的间距 (水平方向的margin是可以叠加的)</code></pre></li></ol></li></ol><p>7、浮动布局<br>    1. float<br>        含义：浮动布局，使用后会使元素向左或者向右移动<br>        取值：<br>            left    左浮动<br>            right    右浮动<br>            none    【默认】不浮动<br>        特点：<br>            1、使用浮动的元素会脱离文档流【置物架】<br>            2、使用浮动的元素的宽、高度默认由内容决定，可设置宽、高<br>            3、原先所在位置就会被其他块元素填充<br>            4、浮动元素在一行中依次排列，当一行无法容纳的时候会自动换行<br>        案例：<br>            1、全部浮动<br>            2、左边浮动，右边不浮动<br>            3、左右浮动，中间不浮动<br>                中间的元素要写在最后面</p><pre><code>    清除浮动的方式        1、浮动元素的父级元素： overflow:hidden;        2、浮动元素的父级元素： ::after{clear:both;content:'';display:block;}        3、浮动元素的同级：添加一个空标签，并且设置clear:both;    1) 七列布局    2) nav的伪元素竖线    拓展        如何让元素使用margin:0 auto，水平居中        只对块级元素生效，所以margin:0 auto的用法分为三种，分别为            块级元素：div、h1~h3、ul                /*对于块级元素，只需要设置width*/                div{                    width: 200px;                    background-color: #ccc;                    margin:0 auto;                }            行内元素：span、a                /*对于行内元素，需要先设置为块级元素，再加宽度*/                span{                    display: block;                    width: 100px;                    background-color: red;                    margin:0 auto;                }            行内块元素：button、img、input、textarea                /*对于行内块级元素，需要设置为块级元素，可以不用设置宽度*/                input{                    display: block;                    margin:0 auto;                }</code></pre><p>8、定位布局<br>    1) 作用：当一个元素悬挂在其他元素之上，优先考虑定位布局<br>            eg: 模态框、二级菜单、固定宣传栏</p><pre><code>2) 特点    1. 可以使用top、right、bottom、left描述当前元素的位置    2. 可以设置z轴距离，z-index    3. 存在参照点    4. 是否脱离文档流3) 用法：    position:static/ relative / absolute / fixed / sticky    static         静态布局，默认文档流中，非定位元素【默认】    relative    相对定位        1) 没有脱离文档流        2) 参照点为当前元素原本的位置    absolute    绝对定位        1) 脱离了文档流        2) 参照距离当前元素最近的父定位元素，如果所有的父元素都没有定位元素，参照浏览器视口        模态框、二级菜单、nav的伪元素竖线        一、有一个盒子，希望子元素距离父元素的上方有间距            1. 给父元素设置内边距                padding-top:50px;            2. 给子元素设置相对定位                position:relative;                top:50px;            3. 给父元素设置相对定位，子元素设置绝对定位                height: 100px;                width:100%;                position:absolute;                top: 50px;            4. 给子元素设置浮动                float:left;                width:100%;                margin-top:50px;        二、水平垂直居中的方法            1. 父元素相对定位，子元素绝对定位，margin:auto;left:0;right:0;top:0;bottom:0;            2. 父元素相对定位，子元素绝对定位，子元素left:50%,top:50%;margin-left:-子元素一半的宽度;margin-top: - 子元素一半的高度     fixed         固定定位        1) 脱离了文档流        2) 参照浏览器视口    sticky         粘滞定位        1) 不脱离文档流        2) relative 和 fixed 的结合            top:50px            当当前元素距离浏览器视口顶端为50px的时候，体现fixed的特点1、overflow    auto：自适应，内容如果溢出，会自动生成滚动条    scroll：将超出的内容进行裁剪（也就是不显示），并以滚动条的方式显示超出的内容（若不设置隐藏滚动条，滚动条一直存在）。    hidden：将超出内容进行裁剪，不会出现滚动条2、浮动与绝对定位脱离文档流的区别(主要体现在 元素内文本的位置)    float：其他盒子会无视当前元素，从浏览器左上角开始布局，而盒子内的文本依旧会为浮动的元素让出位置    绝对定位：其他盒子与盒子内的文本都会无视当前元素，从左上角开始布局</code></pre><p>9.伸缩盒布局<br>    伸缩盒布局<br>    1) 作用：使得子元素在父元素中分列显示，与float的作用类似。一般用于响应式布局（手机app中）</p><pre><code>2) 属性：    display:flex; 将元素设置为伸缩盒布局    flex-direction 主轴的方向        column    y轴(行布局)            上中下        row     x轴(列布局)【默认】  左中右    flex-wrap    自动换行        当多个元素整体的宽度/高度在主轴方向上，超过主轴的大小时，设置换行        wrap    超出时换行        nowrap    超出时不换行【默认】    flex    剩余空间按比例划分        flex-grow    flex容器中剩余空间的多少应该分配给项目（flex增长系数）        flex-shrink    指定了 flex 元素的收缩规则        flex-basis    指定了 flex 元素在主轴方向上的初始大小        速写            flex: grow shrink basis;            举例：        &lt;ul&gt;            &lt;li&gt;&lt;/li&gt;            &lt;li&gt;&lt;/li&gt;            &lt;li&gt;&lt;/li&gt;        &lt;/ul&gt;        父元素 ul  伸缩盒        1）设置父元素为伸缩盒            display:flex        2)主轴（默认情况为x轴，元素按照主轴方向排列）            flex-direction:row / column        3)伸缩盒自动换行(默认不换行nowarp)            display:nowrap / warp        子元素 li   伸缩盒元素        1）基础值（主轴上元素的基础值宽/高）            flex-basis        2）对剩余空间的分配            flex-grow        3）对收缩空间的分配            flex-shrink        速写形式：            flex: grow shrink basisalign-items    交叉轴方向上的显示    stretch    在交叉轴方向被拉伸到与容器相同的高度或宽度    center    在交叉轴居中    flex-start    元素向交叉轴起点对齐    flex-end    元素向交叉轴终点对齐justify-content    主轴方向上的显示    flex-start    元素向交叉轴起点对齐    center    在主轴居中</code></pre><p>10.动画<br>    1) 动画定义<br>        @keyframes 动画名称{<br>            from {</p><pre><code>        }        to{        }    }    =》    @keyframes 动画名称{        10% {                    }        20%{        }        ...        100%{        }    }2) 动画应用    小球运动    animation-name:动画名称;    animation-duration:        动画持续时间        5s;     animation-delay:             动画的延迟        1s    animation-direction     动画运动方向        reverse        alternate    animation-fill-mode:     动画结束后保留哪个样式        forwards    保留最后一帧的样式        backwards 保留第一帧的样式    animation-iteration-count:     动画执行的次数        4        infinite    animation-timing-function:     动画执行的时间曲线        linear        steps        ease        ease-in        ease-out        ease-in-out    animation-play-state: ;    动画播放状态        running        paused    animation:            速写形式     animation: animation-name, animation-duration, animation-timing-function,animation-delay,animation-iteration-count,animation-direction,animation-fill-mode ,animation-play-state    案例：        呼吸灯        梦幻西游        轮播图片    3) 第三方动画库（animate.css）    封装了css3的通用的动画样式，专业    https://daneden.github.io/animate.css/    1. 引入动画库    2. 为元素添加class</code></pre><p>11、过渡效果transition<br>    1) transition和animation的区别<br>        1. transition必须要触发，一般使用:hover<br>        2. transition不需要设置关键帧<br>        简单的过渡效果使用transition，复杂的动画使用animation【属性的多少】</p><pre><code>2) 用法    transition-property     指定过渡的属性        可以不指定属性         none        可以指定一个属性     width        可以指定多个属性    width,background,border...        可以指定所有属性     all    transition-duration     过渡持续的时间        可以指定秒，以及毫秒     s /ms    transition-timing-function     过渡的速度曲线        linear        steps        ease        ease-in        ease-out        ease-in-out    transition-delay             过渡的延迟        可以指定秒，以及毫秒     s /ms    transition                         速写        transition:property duration timing-function delay;        例如：        transition-property: transform,border,margin;        transition-duration: 3s;        transition-timing-function: linear;        ==&gt;        transition: transform 3s linear 1s,border 10s linear 1s,margin 10s linear 1s;    案例        mdn上的案例        网易严选图片放大案例</code></pre><p>12.变形transform<br>    1) 语法<br>        div {<br>            transform: xxx();<br>            transform-origin: center;<br>        }<br>        transform 元素的变形操作<br>        transform-origin 指定元素变形的原点<br>    2) 旋转<br>        rotateX(45deg)        旋转<br>        rotateY(45deg)        旋转<br>        rotateZ(45deg)        旋转<br>        若角度为正，则顺时针方向旋转，否则逆时针方向旋转<br>    3) 倾斜<br>        skewX(45deg)<br>        skewY(45deg)<br>        skew(45deg)<br>    4) 缩放<br>        scale()<br>    5) 移动<br>        translateX(200px)<br>        translateY(300px)<br>        translate(200px,300px)</p><p>博客内容：<br>    1.遇到问题<br>    2.记录方法<br>        iconfont<br>        fontawesome<br>        ttf<br>    3.清除浮动方法    </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>html</title>
      <link href="2021/06/03/html/"/>
      <url>2021/06/03/html/</url>
      
        <content type="html"><![CDATA[<p>1、html【超文本标记语言】 类似于快递上的地址，快递公司根据不同的地址发送目的地<br>    1. 普通文本与超文本<br>        普通文本<br>            纯字符<br>        超文本<br>            字符，图片，超链接，视频，音频<br>        </p><h1>hello world</h1><br>        <p>段落</p><br>        <video src="a.mp4"></video><br>        <a href="http://www.baidu.com">百度一下</a><p></p><pre><code>2. 浏览器由上而下解析html文件，会将标签自动进行转换，变成浏览器页面元素显示</code></pre><p>2、开发环境<br>    编辑器<br>        vscode、sublime<br>    浏览器<br>        firefox、chrome、IE<br>    服务器</p><p>3、B/S架构【浏览器/服务器模式】<br>    B Browser浏览器<br>    S Server服务器</p><pre><code>手机、电脑的浏览器  &lt;--&gt;  各类网站(服务器)  &lt;--&gt;  数据库(java/python/nodejs)演示资源库</code></pre><p>4、html网页<br>    1. 编写hello world</p><pre><code>2. 结构    doctype     声明部分         html    Html的根元素，用来包含html文档的所有元素            head    不会显示到浏览器视口中                title        显示在浏览器选项卡的标题                meta         用于设置元信息，配置                    charset=utf-8                         编码                        编辑器 UTF-8                    解码                        浏览器                                        程序员  编写                     浏览器  解析            body                网页主体3. 基本语法    1) 注释 ctrl + /        &lt;!--注释--&gt;    2) 元素组成        开始标签、内容(文本或者子标签)、结束标签        &lt;div&gt;hello world&lt;/div&gt;        &lt;div&gt;            &lt;span&gt;hello world&lt;/span&gt;        &lt;/div&gt;    3) 属性        在开始标签中可以添加属性            &lt;div 属性名=属性值 属性名=属性值&gt;                属性名不区分大小写                &lt;div id="one"&gt;&lt;/div&gt;                &lt;div ID="one"&gt;&lt;/div&gt;        1. 核心属性【绝大多数标签都可以应用的属性】            id             文档内部的唯一标识            class     类                &lt;div class="first one"&gt;one&lt;/div&gt;                &lt;div class="first two"&gt;two&lt;/div&gt;                &lt;div class="first three"&gt;three&lt;/div&gt;            title     描述            style     样式，取值为css规则                css规则,键值对，键值之间通过冒号分割，规则之间通过分号分割                &lt;div id='one' style="color:#333;backgroud:#ededed"&gt;&lt;/div&gt;        2. 特有属性【某些标签特有的】            a                href                target            img                alt                src    4) 元素分类        1. 块级元素            作用：作为页面框架，或者容器。是页面的主体            特性：                1) 独占一行空间                2) 默认宽度为100%，默认高度由子元素或者内容决定                 3) 可以为其指定宽高 style="width:;height:;"                 div     无意义的块元素                h1~h3    标题                    font-size                    font-weight                    margin                p         段落                    margin                html                body                    margin                ul、li     无序列表，列表项                        ul                        margin                        padding                        list-style                    li                ol、li      有序列表，列表项                    ol                        margin                        padding                        list-style                dl、dt、dd     有序列表                    dl                        margin                    dd                        margin                H5新增的块元素（语义化标签）                    header(头)                    nav                    article（主体）                    section (部分)                    footer（脚）                    video                    audio        2. 行内元素            作用：点缀网页，填充内容            特性：                1) 与其他行内元素共享一行空间                2) 默认宽高由内容决定                3) 不能为其指定宽和高                4) 行内元素中不可以嵌套块元素，但块元素中可以嵌套行内元素            span     无意义的行内元素            a         超级链接                默认样式                    color                    text-decoration                    cursor                默认事件（js - dom） 点击事件                href                    url                    相对路径                    绝对路径                    锚点                target                    _self   当前页打开                    _blank  新建选项卡打开            img                src     图片地址                    url         http://                    相对路径                        绝对路径    file://从根目录开始                alt     图片找不到的时候显示的文本                &lt;img src="" alt=""&gt;            strong            bold            b            em            i            sub            sup            ...        3. 功能元素    （行内元素）            1) 表格                table                    【属性】border、width、、、、                    caption     表格标题                    thead         表头部分                        tr                             th/td                    tbody         表格主体部分【不可以省略】                        tr                            td/th                            【属性】colspan、rowspan、width、align                            td/th中可以放任意子元素                    tfoot         表底部分                        tr                            td                【注意】：每一行中的列数应该是相等                案例：个人计划表                作业：制作个人简历、课表            2) 表单（前后台交互）                    用户 -&gt; 表单 -&gt; 后台 -&gt; 数据库                    注册页面                    登录页面                    搜索框                    &lt;form action=""&gt;                        input                        select                        textarea                    &lt;/form&gt;                    form                        action     后台接口地址                        method     请求方式                            get                                参数拼接在url后面，通过?来分割                                传递参数较少                            post                                参数存放在请求体中，安全                                传递参数更多                        enctype 编码方式                            1. enctype='application/x-www-form-urlencoded'                                浏览器就会将参数转换为【查询字符串 qs】格式                                username=tom&amp;password=123321&amp;                            2. multipart/form-data                                当有附件在表单中的时候，enctype务必设置为这种格式                    input                        name:             作为参数中的key                        value:             作为参数中的value,在按钮中务必指定value值                        type:                            text         单行文本框                            password     密码框                            submit         提交按钮                            radio         单选按钮                            checkbox     复选按钮                            file         附件选择器                        checked         单值属性    默认选择                        placeholder     提示语                    select                        option                            标签中的文本显示在网页中，提交的值应该是option的value值，当这个值没有设定的时候，提交的是标签中的文本                            &lt;option value="sx"&gt;山西&lt;/option&gt;                    textarea                        多行文本域                        placeholder 提示语                    第三方库                        日期插件                        地址选择器地址                        附件上传                        富文本            3) H5新增                标签                    progress 进度条                    output 表示用户动作产生的结果                    datalist 表示其他控件可用的值                属性                    type                        date    日期                        datetime-local     日期时间控件                        time     时间控件                        number     数字控件（只能输入数字）                        range     范围控件（通过控制条可以调整取值）                        search     搜索控件                        tel     电话控件                        url     地址控件                        color     颜色控件                        email      email控件</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Usage Tips</title>
      <link href="2021/06/03/usage-tips/"/>
      <url>2021/06/03/usage-tips/</url>
      
        <content type="html"><![CDATA[<h2 id="Step-1-新建文章"><a href="#Step-1-新建文章" class="headerlink" title="Step 1: 新建文章"></a>Step 1: 新建文章</h2><p>在hexo所在目录下，打开terminal，在命令行输入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new a</span><br></pre></td></tr></tbody></table></figure><p>a是文章标题，也可以加上双引号,如“a”。<br> 通过这行命令，我们新建出来了一个page，而且是一个post page，page还有其他种，稍后我们会提到。<br> 正确的结果：我们会在_posts里看见多了一个a.md文件。<br> 因此我们也知道了，默认情况下，hexo为我们创建的是markdown文件。刷新页面（<a href="https://link.jianshu.com/?t=http://localhost:4000/">http://localhost:4000/</a>）我们能看见新添一个名字叫a的文章，没有任何内容。<br> 而这个_posts文件夹，算是一个比较特殊的文件夹，因为它装着所有你发布出去的文章。</p><p>打开a.md文件，我们会看到</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: <span class="number">1</span></span><br><span class="line">date: <span class="number">2017</span>-<span class="number">09</span>-<span class="number">15</span> <span class="number">19</span>:<span class="number">00</span>:<span class="number">41</span></span><br><span class="line">tags:</span><br><span class="line">---</span><br><span class="line">在这里随便写点什么</span><br></pre></td></tr></tbody></table></figure><p>然后刷新页面,就会看到你写的内容。与此同时，hexo也会自动为这个post生成一个页面，当我们点击标题，就会进入那个页面。</p><h2 id="Step-2-草稿箱"><a href="#Step-2-草稿箱" class="headerlink" title="Step 2:  草稿箱"></a>Step 2:  草稿箱</h2><p>上一步我们新建出来的，叫做post page。除了post page，我们还可以新建draft page，也就是草稿。很多时候我们需要先写成草稿，而暂时不发布出去。draft page就可以满足我们的要求，我们的网站上是看不到草稿文件的。</p><p>在terminal输入</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft b</span><br></pre></td></tr></tbody></table></figure><p>我们会在source下看见一个新的文件夹，_drafts，这个里面会装我们所有的草稿文件。</p><p>那写好了的草稿，如何可以在不发布的情况下，预览一下文章在网站上的样子呢？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></tbody></table></figure><p>当然，你要先shut down原来开着那个server，才可以开启新的server。如此一来，我们就可以预览草稿文件啦</p><h2 id="Step-3-发布草稿"><a href="#Step-3-发布草稿" class="headerlink" title="Step 3: 发布草稿"></a>Step 3: 发布草稿</h2><p>当你准备好了要发布草稿时:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish b</span><br></pre></td></tr></tbody></table></figure><p>你会发现_drafts里的b.md不见了，跑到了_posts里面,也就说明你的草稿发布成功了。</p><h2 id="Step-4-normal-page"><a href="#Step-4-normal-page" class="headerlink" title="Step 4: normal page"></a>Step 4: normal page</h2><p>我目前还不知道该如何用中文称呼这类页面。我们可以把post和draft统称为blog pages，在这之外的一种就是normal pages， 类似一个网站上的“关于”，“了解我们”之类的页面。</p><p>这类page要如何新建呢？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page c</span><br></pre></td></tr></tbody></table></figure><p>和前两种不同，这个命令会在source文件夹内创建出c文件夹，与_posts，_drafts并列。文件夹里面有一个index.md文件。</p><p>刷新页面，你会发现c并没有出现在页面内，那它在哪儿呢？</p><p>在网址后面加上c/， 即<a href="https://link.jianshu.com/?t=http://localhost:4000/c/">http://localhost:4000/c/</a>，就可以看到了。</p><p>正因为c不是一个blog page，所以它也不会出现在blog列表中，而是要通过URL去access。</p><h2 id="Step-5-一个小tip"><a href="#Step-5-一个小tip" class="headerlink" title="Step 5: 一个小tip"></a>Step 5: 一个小tip</h2><p>现在我们了解到page一共有三种，post，draft，normal。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
